{"ast":null,"code":"export const analyzeProductivity = (routineLogs, tasks) => {\n  if (routineLogs.length < 3) {\n    return [{\n      icon: 'ðŸ“š',\n      text: 'Log more routines to unlock AI recommendations',\n      timeRange: 'Get started today',\n      type: 'info'\n    }];\n  }\n  const recommendations = [];\n  const productiveHours = findProductiveHours(routineLogs);\n  if (productiveHours.length > 0) {\n    recommendations.push({\n      icon: 'ðŸŽ¯',\n      text: `Your focus is highest between ${productiveHours[0]}`,\n      timeRange: 'Schedule important tasks here',\n      type: 'productivity'\n    });\n  }\n  const lowProductivityHours = findLowProductivityHours(routineLogs);\n  if (lowProductivityHours.length > 0) {\n    recommendations.push({\n      icon: 'âš ï¸',\n      text: `Avoid heavy tasks around ${lowProductivityHours[0]}`,\n      timeRange: 'Take breaks or do light activities',\n      type: 'warning'\n    });\n  }\n  const sleepAnalysis = analyzeSleepPerformance(routineLogs);\n  if (sleepAnalysis.needsMoreSleep) {\n    recommendations.push({\n      icon: 'ðŸ˜´',\n      text: sleepAnalysis.message,\n      timeRange: 'Sleep affects your performance',\n      type: 'health'\n    });\n  }\n  const upcomingHighPriority = tasks.filter(t => !t.completed && t.priority === 'High').sort((a, b) => new Date(a.deadline) - new Date(b.deadline))[0];\n  if (upcomingHighPriority) {\n    const hoursUntil = Math.floor((new Date(upcomingHighPriority.deadline) - new Date()) / (1000 * 60 * 60));\n    if (hoursUntil < 24 && hoursUntil > 0) {\n      recommendations.push({\n        icon: 'ðŸ”¥',\n        text: `High-priority task deadline in ${hoursUntil} hours`,\n        timeRange: upcomingHighPriority.name,\n        type: 'urgent'\n      });\n    }\n  }\n  const freeSlot = findNextFreeSlot(tasks);\n  if (freeSlot) {\n    recommendations.push({\n      icon: 'âœ¨',\n      text: 'Free slot available - recommended study time',\n      timeRange: freeSlot,\n      type: 'opportunity'\n    });\n  }\n  return recommendations;\n};\nconst findProductiveHours = logs => {\n  const hourlyProductivity = {};\n  logs.forEach(log => {\n    if (log.studyHours > 0) {\n      const hour = new Date(log.date).getHours();\n      hourlyProductivity[hour] = (hourlyProductivity[hour] || 0) + log.studyHours;\n    }\n  });\n  const sortedHours = Object.entries(hourlyProductivity).sort((a, b) => b[1] - a[1]).map(([hour]) => {\n    const h = parseInt(hour);\n    return `${h}:00 - ${h + 2}:00`;\n  });\n  return sortedHours;\n};\nconst findLowProductivityHours = logs => {\n  const hourlyBreaks = {};\n  logs.forEach(log => {\n    if (log.breaks > 30) {\n      const hour = new Date(log.date).getHours();\n      hourlyBreaks[hour] = (hourlyBreaks[hour] || 0) + 1;\n    }\n  });\n  return Object.entries(hourlyBreaks).sort((a, b) => b[1] - a[1]).map(([hour]) => {\n    const h = parseInt(hour);\n    return `${h}:00 - ${h + 1}:00`;\n  }).slice(0, 1);\n};\nconst analyzeSleepPerformance = logs => {\n  const recentLogs = logs.slice(-7);\n  const avgSleep = recentLogs.reduce((sum, log) => {\n    const sleep = calculateSleepHours(log.wakeupTime, log.sleepTime);\n    return sum + sleep;\n  }, 0) / recentLogs.length;\n  if (avgSleep < 6) {\n    return {\n      needsMoreSleep: true,\n      message: 'Sleep earlier - performance drops on 6-hr sleep days'\n    };\n  } else if (avgSleep > 9) {\n    return {\n      needsMoreSleep: true,\n      message: 'You might be oversleeping - 7-8 hours is optimal'\n    };\n  }\n  return {\n    needsMoreSleep: false\n  };\n};\nconst calculateSleepHours = (wakeup, sleep) => {\n  if (!wakeup || !sleep) return 7;\n  const [wh, wm] = wakeup.split(':').map(Number);\n  const [sh, sm] = sleep.split(':').map(Number);\n  let hours = wh - sh;\n  if (hours < 0) hours += 24;\n  return hours;\n};\nconst findNextFreeSlot = tasks => {\n  const now = new Date();\n  const today = tasks.filter(t => !t.completed && new Date(t.deadline).toDateString() === now.toDateString());\n  if (today.length === 0) {\n    const currentHour = now.getHours();\n    if (currentHour >= 9 && currentHour < 22) {\n      return `Now - ${currentHour + 1}:00`;\n    }\n  }\n  return null;\n};\nexport const detectTaskConflicts = (tasks, newTask) => {\n  const conflicts = [];\n  const newStart = new Date(newTask.scheduledTime);\n  const newEnd = new Date(newStart.getTime() + newTask.duration * 60 * 60 * 1000);\n  tasks.forEach(task => {\n    if (task.id === newTask.id || task.completed) return;\n    const taskStart = new Date(task.scheduledTime);\n    const taskEnd = new Date(taskStart.getTime() + task.duration * 60 * 60 * 1000);\n    if (newStart >= taskStart && newStart < taskEnd || newEnd > taskStart && newEnd <= taskEnd || newStart <= taskStart && newEnd >= taskEnd) {\n      conflicts.push(task);\n    }\n  });\n  return conflicts;\n};\nexport const recommendTimeSlot = (tasks, duration) => {\n  const workingHours = [];\n  for (let hour = 6; hour <= 22; hour++) {\n    workingHours.push(hour);\n  }\n  const today = new Date();\n  const recommendations = [];\n  workingHours.forEach(hour => {\n    const slotStart = new Date(today);\n    slotStart.setHours(hour, 0, 0, 0);\n    const slotEnd = new Date(slotStart.getTime() + duration * 60 * 60 * 1000);\n    const hasConflict = tasks.some(task => {\n      if (task.completed) return false;\n      const taskStart = new Date(task.scheduledTime);\n      const taskEnd = new Date(taskStart.getTime() + task.duration * 60 * 60 * 1000);\n      return slotStart >= taskStart && slotStart < taskEnd || slotEnd > taskStart && slotEnd <= taskEnd;\n    });\n    if (!hasConflict) {\n      recommendations.push({\n        time: `${hour}:00`,\n        score: calculateTimeScore(hour),\n        reason: getTimeReason(hour)\n      });\n    }\n  });\n  return recommendations.sort((a, b) => b.score - a.score).slice(0, 3);\n};\nconst calculateTimeScore = hour => {\n  if (hour >= 7 && hour <= 9) return 95;\n  if (hour >= 19 && hour <= 21) return 90;\n  if (hour >= 14 && hour <= 16) return 70;\n  if (hour >= 10 && hour <= 12) return 85;\n  return 60;\n};\nconst getTimeReason = hour => {\n  if (hour >= 7 && hour <= 9) return 'Morning peak focus time';\n  if (hour >= 19 && hour <= 21) return 'Evening high productivity';\n  if (hour >= 14 && hour <= 16) return 'Post-lunch moderate energy';\n  if (hour >= 10 && hour <= 12) return 'Late morning clarity';\n  return 'Available time slot';\n};","map":{"version":3,"names":["analyzeProductivity","routineLogs","tasks","length","icon","text","timeRange","type","recommendations","productiveHours","findProductiveHours","push","lowProductivityHours","findLowProductivityHours","sleepAnalysis","analyzeSleepPerformance","needsMoreSleep","message","upcomingHighPriority","filter","t","completed","priority","sort","a","b","Date","deadline","hoursUntil","Math","floor","name","freeSlot","findNextFreeSlot","logs","hourlyProductivity","forEach","log","studyHours","hour","date","getHours","sortedHours","Object","entries","map","h","parseInt","hourlyBreaks","breaks","slice","recentLogs","avgSleep","reduce","sum","sleep","calculateSleepHours","wakeupTime","sleepTime","wakeup","wh","wm","split","Number","sh","sm","hours","now","today","toDateString","currentHour","detectTaskConflicts","newTask","conflicts","newStart","scheduledTime","newEnd","getTime","duration","task","id","taskStart","taskEnd","recommendTimeSlot","workingHours","slotStart","setHours","slotEnd","hasConflict","some","time","score","calculateTimeScore","reason","getTimeReason"],"sources":["C:/Users/karan/OneDrive/Desktop/hackthon/Student productivity/src/utils/aiEngine.js"],"sourcesContent":["export const analyzeProductivity = (routineLogs, tasks) => {\r\n  if (routineLogs.length < 3) {\r\n    return [\r\n      {\r\n        icon: 'ðŸ“š',\r\n        text: 'Log more routines to unlock AI recommendations',\r\n        timeRange: 'Get started today',\r\n        type: 'info'\r\n      }\r\n    ];\r\n  }\r\n\r\n  const recommendations = [];\r\n  \r\n  const productiveHours = findProductiveHours(routineLogs);\r\n  if (productiveHours.length > 0) {\r\n    recommendations.push({\r\n      icon: 'ðŸŽ¯',\r\n      text: `Your focus is highest between ${productiveHours[0]}`,\r\n      timeRange: 'Schedule important tasks here',\r\n      type: 'productivity'\r\n    });\r\n  }\r\n\r\n  const lowProductivityHours = findLowProductivityHours(routineLogs);\r\n  if (lowProductivityHours.length > 0) {\r\n    recommendations.push({\r\n      icon: 'âš ï¸',\r\n      text: `Avoid heavy tasks around ${lowProductivityHours[0]}`,\r\n      timeRange: 'Take breaks or do light activities',\r\n      type: 'warning'\r\n    });\r\n  }\r\n\r\n  const sleepAnalysis = analyzeSleepPerformance(routineLogs);\r\n  if (sleepAnalysis.needsMoreSleep) {\r\n    recommendations.push({\r\n      icon: 'ðŸ˜´',\r\n      text: sleepAnalysis.message,\r\n      timeRange: 'Sleep affects your performance',\r\n      type: 'health'\r\n    });\r\n  }\r\n\r\n  const upcomingHighPriority = tasks\r\n    .filter(t => !t.completed && t.priority === 'High')\r\n    .sort((a, b) => new Date(a.deadline) - new Date(b.deadline))[0];\r\n    \r\n  if (upcomingHighPriority) {\r\n    const hoursUntil = Math.floor(\r\n      (new Date(upcomingHighPriority.deadline) - new Date()) / (1000 * 60 * 60)\r\n    );\r\n    if (hoursUntil < 24 && hoursUntil > 0) {\r\n      recommendations.push({\r\n        icon: 'ðŸ”¥',\r\n        text: `High-priority task deadline in ${hoursUntil} hours`,\r\n        timeRange: upcomingHighPriority.name,\r\n        type: 'urgent'\r\n      });\r\n    }\r\n  }\r\n\r\n  const freeSlot = findNextFreeSlot(tasks);\r\n  if (freeSlot) {\r\n    recommendations.push({\r\n      icon: 'âœ¨',\r\n      text: 'Free slot available - recommended study time',\r\n      timeRange: freeSlot,\r\n      type: 'opportunity'\r\n    });\r\n  }\r\n\r\n  return recommendations;\r\n};\r\n\r\nconst findProductiveHours = (logs) => {\r\n  const hourlyProductivity = {};\r\n  \r\n  logs.forEach(log => {\r\n    if (log.studyHours > 0) {\r\n      const hour = new Date(log.date).getHours();\r\n      hourlyProductivity[hour] = (hourlyProductivity[hour] || 0) + log.studyHours;\r\n    }\r\n  });\r\n\r\n  const sortedHours = Object.entries(hourlyProductivity)\r\n    .sort((a, b) => b[1] - a[1])\r\n    .map(([hour]) => {\r\n      const h = parseInt(hour);\r\n      return `${h}:00 - ${h + 2}:00`;\r\n    });\r\n\r\n  return sortedHours;\r\n};\r\n\r\nconst findLowProductivityHours = (logs) => {\r\n  const hourlyBreaks = {};\r\n  \r\n  logs.forEach(log => {\r\n    if (log.breaks > 30) {\r\n      const hour = new Date(log.date).getHours();\r\n      hourlyBreaks[hour] = (hourlyBreaks[hour] || 0) + 1;\r\n    }\r\n  });\r\n\r\n  return Object.entries(hourlyBreaks)\r\n    .sort((a, b) => b[1] - a[1])\r\n    .map(([hour]) => {\r\n      const h = parseInt(hour);\r\n      return `${h}:00 - ${h + 1}:00`;\r\n    })\r\n    .slice(0, 1);\r\n};\r\n\r\nconst analyzeSleepPerformance = (logs) => {\r\n  const recentLogs = logs.slice(-7);\r\n  const avgSleep = recentLogs.reduce((sum, log) => {\r\n    const sleep = calculateSleepHours(log.wakeupTime, log.sleepTime);\r\n    return sum + sleep;\r\n  }, 0) / recentLogs.length;\r\n\r\n  if (avgSleep < 6) {\r\n    return {\r\n      needsMoreSleep: true,\r\n      message: 'Sleep earlier - performance drops on 6-hr sleep days'\r\n    };\r\n  } else if (avgSleep > 9) {\r\n    return {\r\n      needsMoreSleep: true,\r\n      message: 'You might be oversleeping - 7-8 hours is optimal'\r\n    };\r\n  }\r\n\r\n  return { needsMoreSleep: false };\r\n};\r\n\r\nconst calculateSleepHours = (wakeup, sleep) => {\r\n  if (!wakeup || !sleep) return 7;\r\n  \r\n  const [wh, wm] = wakeup.split(':').map(Number);\r\n  const [sh, sm] = sleep.split(':').map(Number);\r\n  \r\n  let hours = wh - sh;\r\n  if (hours < 0) hours += 24;\r\n  \r\n  return hours;\r\n};\r\n\r\nconst findNextFreeSlot = (tasks) => {\r\n  const now = new Date();\r\n  const today = tasks.filter(t => \r\n    !t.completed && \r\n    new Date(t.deadline).toDateString() === now.toDateString()\r\n  );\r\n\r\n  if (today.length === 0) {\r\n    const currentHour = now.getHours();\r\n    if (currentHour >= 9 && currentHour < 22) {\r\n      return `Now - ${currentHour + 1}:00`;\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport const detectTaskConflicts = (tasks, newTask) => {\r\n  const conflicts = [];\r\n  \r\n  const newStart = new Date(newTask.scheduledTime);\r\n  const newEnd = new Date(newStart.getTime() + newTask.duration * 60 * 60 * 1000);\r\n\r\n  tasks.forEach(task => {\r\n    if (task.id === newTask.id || task.completed) return;\r\n    \r\n    const taskStart = new Date(task.scheduledTime);\r\n    const taskEnd = new Date(taskStart.getTime() + task.duration * 60 * 60 * 1000);\r\n\r\n    if (\r\n      (newStart >= taskStart && newStart < taskEnd) ||\r\n      (newEnd > taskStart && newEnd <= taskEnd) ||\r\n      (newStart <= taskStart && newEnd >= taskEnd)\r\n    ) {\r\n      conflicts.push(task);\r\n    }\r\n  });\r\n\r\n  return conflicts;\r\n};\r\n\r\nexport const recommendTimeSlot = (tasks, duration) => {\r\n  const workingHours = [];\r\n  for (let hour = 6; hour <= 22; hour++) {\r\n    workingHours.push(hour);\r\n  }\r\n\r\n  const today = new Date();\r\n  const recommendations = [];\r\n\r\n  workingHours.forEach(hour => {\r\n    const slotStart = new Date(today);\r\n    slotStart.setHours(hour, 0, 0, 0);\r\n    const slotEnd = new Date(slotStart.getTime() + duration * 60 * 60 * 1000);\r\n\r\n    const hasConflict = tasks.some(task => {\r\n      if (task.completed) return false;\r\n      const taskStart = new Date(task.scheduledTime);\r\n      const taskEnd = new Date(taskStart.getTime() + task.duration * 60 * 60 * 1000);\r\n      \r\n      return (\r\n        (slotStart >= taskStart && slotStart < taskEnd) ||\r\n        (slotEnd > taskStart && slotEnd <= taskEnd)\r\n      );\r\n    });\r\n\r\n    if (!hasConflict) {\r\n      recommendations.push({\r\n        time: `${hour}:00`,\r\n        score: calculateTimeScore(hour),\r\n        reason: getTimeReason(hour)\r\n      });\r\n    }\r\n  });\r\n\r\n  return recommendations\r\n    .sort((a, b) => b.score - a.score)\r\n    .slice(0, 3);\r\n};\r\n\r\nconst calculateTimeScore = (hour) => {\r\n  if (hour >= 7 && hour <= 9) return 95;\r\n  if (hour >= 19 && hour <= 21) return 90;\r\n  if (hour >= 14 && hour <= 16) return 70;\r\n  if (hour >= 10 && hour <= 12) return 85;\r\n  return 60;\r\n};\r\n\r\nconst getTimeReason = (hour) => {\r\n  if (hour >= 7 && hour <= 9) return 'Morning peak focus time';\r\n  if (hour >= 19 && hour <= 21) return 'Evening high productivity';\r\n  if (hour >= 14 && hour <= 16) return 'Post-lunch moderate energy';\r\n  if (hour >= 10 && hour <= 12) return 'Late morning clarity';\r\n  return 'Available time slot';\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}